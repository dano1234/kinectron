<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Hello World!</title>
    <script src="peer.min.js"></script>
    <script src="js/fps.js"></script>
    <script type="text/JavaScript">
      var Kinect2 = require('kinect2');
      var kinect = new Kinect2();

      var mypeerid = null;
      var peer = null;
      var peer_ids = [];
      var peer_connections = [];

      var canvas = null;
      var context = null;

      var outputCanvas = null;
      var outputContext = null;

      var imageData = null;
      var imageDataSize = null;
      var imageDataArray = null;

      var busy = false;
      //var state = null;

      //added for floor height joint 
      var ImageBufferRendererWebgl = require('./js/image-buffer-renderer-webgl.js');
      var colorRenderer = null;

      function initpeer() {
          peer = new Peer('lisa',{host: 'liveweb.itp.io', port: 9000, path: '/', secure: true});

          peer.on('error',function(err) {
            console.log(err);
          });

          peer.on('open', function(id) {
            console.log('My peer ID is: ' + id);
            mypeerid = id;
        });

        peer.on('connection', function(conn) {
          connection = conn;
          console.log("Got a new data connection from peer: "+connection.peer);
          peer_connections.push(connection);

          connection.on('open', function() {
            console.log("Connection opened.");
          });
          connection.on('data', function(data) {
            console.log("Data Received: "+data);
          });
        });

      }

      function sendToPeer(evt, data) {
        var dataToSend = {"event": evt, "data": data};
        peer_connections.forEach(function(connection) {
          connection.send(dataToSend);
        });
      }

      // Key Tracking needs cleanup
      var trackedBodyIndex = -1;
      var emptyPixels = new Uint8Array(1920 * 1080 * 4);

      function getClosestBodyIndex(bodies) {
    		var closestZ = Number.MAX_VALUE;
    		var closestBodyIndex = -1;
    		for(var i = 0; i < bodies.length; i++) {
    			if(bodies[i].tracked && bodies[i].joints[Kinect2.JointType.spineMid].cameraZ < closestZ) {
    				closestZ = bodies[i].joints[Kinect2.JointType.spineMid].cameraZ;
    				closestBodyIndex = i;
    			}
    		}
    		return closestBodyIndex;
    	}

      function startKey() {
        console.log('start key');
        // if (state === null) {
        //   state = 'key';  
        // }
        
        canvas.width = 1920;
        canvas.height = 1080;
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;

        //if (state === 'key') {
          if(kinect.open()) {
          		kinect.on('multiSourceFrame', function(frame) {

                if(busy) {
                  return;
                }
                busy = true;

          			var closestBodyIndex = getClosestBodyIndex(frame.body.bodies);
          			if(closestBodyIndex !== trackedBodyIndex) {
          				if(closestBodyIndex > -1) {
          					kinect.trackPixelsForBodyIndices([closestBodyIndex]);
          				} else {
          					kinect.trackPixelsForBodyIndices(false);
          					//clear canvas
          				}
          			}
          			else {
          				if (closestBodyIndex > -1) {
          					if (frame.bodyIndexColor.bodies[closestBodyIndex].buffer) {
          						//processImageData(frame.bodyIndexColor.bodies[closestBodyIndex].buffer, canvas.width, canvas.height);

                      newPixelData = frame.bodyIndexColor.bodies[closestBodyIndex].buffer


                          for (var i = 0; i < imageDataSize; i++) {
                            imageDataArray[i] = newPixelData[i];
                          }
                          context.putImageData(imageData, 0, 0);

                          outputContext.clearRect(0,0,outputCanvas.width,outputCanvas.height);

                          outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
                          
                          console.log('sending key');
                          sendToPeer('colorFrame',outputCanvas.toDataURL("image/jpeg"));

          					}
          				}
          			}
          			trackedBodyIndex = closestBodyIndex;
                busy = false;

              }); // kinect.on
            } // open
          
          kinect.openMultiSourceReader({
                frameTypes: Kinect2.FrameType.bodyIndexColor | Kinect2.FrameType.body
          });
        }
     //}

      function stopKey() {
        console.log('stopping key');
        //kinect.closeMultiSourceReader();
        //kinect.close();
        busy = false;
        //state = null;
      }

      function startGLKey(){
        console.log('start gl key');
        // if (state === null) {
        //   state = 'gl';  
        // }
        
        colorRenderer = new ImageBufferRendererWebgl(colorCanvas);

        //canvas.width = 1920;
        //canvas.height = 1080;

        //if (state === 'gl') {
          if(kinect.open()) {
          kinect.on('multiSourceFrame', function(frame){

            if(busy) {
                return;
            }
            busy = true;
            
            var closestBodyIndex = getClosestBodyIndex(frame.body.bodies);
            if(closestBodyIndex !== trackedBodyIndex) {
              if(closestBodyIndex > -1) {
                kinect.trackPixelsForBodyIndices([closestBodyIndex]);
              } else {
                kinect.trackPixelsForBodyIndices(false);
                //clear canvas
                processImageData(emptyPixels.buffer, colorCanvas.width, colorCanvas.height);


              }
            }
            else {
              if(closestBodyIndex > -1) {
                if(frame.bodyIndexColor.bodies[closestBodyIndex].buffer) {
                  processImageData(frame.bodyIndexColor.bodies[closestBodyIndex].buffer, colorCanvas.width, colorCanvas.height);

                    console.log('sending webGLFrame');
                    sendToPeer('webGLFrame', colorCanvas.toDataURL('image/jpeg'));
                }
              }
            }
            trackedBodyIndex = closestBodyIndex;
            busy = false;

          });

          kinect.openMultiSourceReader({
            frameTypes: Kinect2.FrameType.bodyIndexColor | Kinect2.FrameType.body
          });
          }
        //}

      }

      function stopGLKey() {
        console.log('stop gl key');
        //kinect.closeMultiSourceReader();
        busy = false;
        //state = null;
      }

      function startTracking() {
            if (kinect.open()) {
      	       console.log("Kinect Opened");

               //listen for body frames
      	        kinect.on('bodyFrame', function(bodyFrame){
                  sendToPeer('bodyFrame',bodyFrame);
      		          // for (var i = 0;  i < bodyFrame.bodies.length; i++) {
      			        //      if (bodyFrame.bodies[i].tracked) {
                    //        console.log("Tracked");
                    //        sendToPeer('bodyFrame',bodyFrame);
                    //        console.log(bodyFrame);
      			        //      }
      		          // }
      	        });

      	        //request body frames
      	        kinect.openBodyReader();
            }
      }

      function stopTracking() {
        kinect.close();
      }


      function startRGB() {

        canvas.width = 1920;
        canvas.height = 1080;
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;

        if(kinect.open()) {
          kinect.on('colorFrame', function(newPixelData){
            //console.log(newPixelData.length);
            if(busy) {
              return;
            }
            busy = true;
            //sendToPeer('colorFrame',newPixelData);

            for (var i = 0; i < imageDataSize; i++) {
              imageDataArray[i] = newPixelData[i];
            }
            context.putImageData(imageData, 0, 0);
            outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
            sendToPeer('colorFrame',outputCanvas.toDataURL("image/jpeg", 0.5));
            busy = false;
          });
        }
        kinect.openColorReader();

      }

      function stopRGB() {
        kinect.closeColorReader();
        busy = false;
      }

      function startDepth() {
        console.log("startDepth Camera");

        canvas.width = 512;
        canvas.height = 424;
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;

        if(kinect.open()) {
          kinect.on('depthFrame', function(newPixelData){
            console.log("depthFrame");
        					if(busy) {
        						return;
        					}
        					busy = true;

                  newPixelDataIndex = 0;
                  for (var i = 0; i < imageDataSize; i+=4) {
                    imageDataArray[i] = newPixelData[newPixelDataIndex];
                    imageDataArray[i+1] = newPixelData[newPixelDataIndex];
                    imageDataArray[i+2] = newPixelData[newPixelDataIndex];
                    imageDataArray[i+3] = newPixelData[newPixelDataIndex];
                    newPixelDataIndex++;
                  }
                  context.putImageData(imageData, 0, 0);
                  outputContext.clearRect(0,0,outputCanvas.width, outputCanvas.height);
                  outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
                  sendToPeer('depthFrame',outputCanvas.toDataURL("image/jpeg", 0.5));
        					busy = false;
        				});
        			}
        kinect.openDepthReader();
      }

      function stopDepth() {
        kinect.closeDepthReader();
        busy = false;
      }

      function startInfrared() {
        console.log('starting Infrared Camera');

        canvas.width = 512;
        canvas.height = 424;
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;

        

        if(kinect.open()) {
          kinect.on('infraredFrame', function(imageBuffer){
            if(busy) {
              return;
            }
  
            busy = true;
  
            var pixelArray = imageData.data;
            var newPixelData = new Uint8Array(imageBuffer);
            var depthPixelIndex = 0;
    
            for (var i = 0; i < imageDataSize; i+=4) {
              pixelArray[i] = newPixelData[depthPixelIndex];
              pixelArray[i+1] = newPixelData[depthPixelIndex];
              pixelArray[i+2] = newPixelData[depthPixelIndex];
              pixelArray[i+3] = 0xff;
              depthPixelIndex++
            }
  
            context.putImageData(imageData, 0, 0);
            
            outputContext.clearRect(0,0,outputCanvas.width, outputCanvas.height);
            outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
            sendToPeer('infraredFrame',outputCanvas.toDataURL("image/jpeg", 0.5));

            busy = false;
          });

        }

        kinect.openInfraredReader();

      }


      function stopInfrared() {
        console.log('stopping Infrared Camera');
        kinect.closeInfraredReader();
        busy = false;
      }

      function startLEInfrared() {
        console.log('starting LE Infrared');

        canvas.width = 512;
        canvas.height = 424;
        var imageData = context.createImageData(canvas.width, canvas.height);
        var imageDataSize = imageData.data.length;

        if(kinect.open()) {
          kinect.on('longExposureInfraredFrame', function(imageBuffer){
            if(busy) {
              return;
            }

            busy = true;
            var pixelArray = imageData.data;
            var newPixelData = new Uint8Array(imageBuffer);
            var depthPixelIndex = 0;
            for (var i = 0; i < imageDataSize; i+=4) {
              pixelArray[i] = newPixelData[depthPixelIndex];
              pixelArray[i+1] = newPixelData[depthPixelIndex];
              pixelArray[i+2] = newPixelData[depthPixelIndex];
              pixelArray[i+3] = 0xff;
              depthPixelIndex++
            }
            
            context.putImageData(imageData, 0, 0);
            outputContext.clearRect(0,0,outputCanvas.width, outputCanvas.height);
            outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
            sendToPeer('infraredFrame',outputCanvas.toDataURL("image/jpeg", 0.5));

            busy = false;
          });

        }

        kinect.openLongExposureInfraredReader();
      }

      function stopLEInfrared() {
        console.log('stopping LE Infrared');
        kinect.closeLongExposureInfraredReader();
        busy = false;
      }

      function processImageData(imageBuffer, width, height) {

        if (colorRenderer.isProcessing || (width <= 0) || (height <= 0)) {
          return;
        }

        colorRenderer.isProcessing = true;
        colorRenderer.processImageData(imageBuffer, width, height);
        colorRenderer.isProcessing = false;

      }

      function startFHJoint() {
        console.log('starting FHJoint');

        canvas.width = 1920;
        canvas.height = 1080;

        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;
        
        var hiddenCanvas = document.createElement('canvas');
        hiddenCanvas.setAttribute('width', 1920);
        hiddenCanvas.setAttribute('height', 1080);

        colorRenderer = new ImageBufferRendererWebgl(hiddenCanvas);
        trackedBodyIndex = -1;

        if(kinect.open()) {
          kinect.on('multiSourceFrame', function(frame){
            //draw camera feed - fast to hidden webgl canvas - copy to visible 2D canvas
            processImageData(frame.color.buffer, canvas.width, canvas.height);
            context.drawImage(hiddenCanvas, 0, 0);

            outputContext.clearRect(0,0,outputCanvas.width,outputCanvas.height);

            outputContext.drawImage(canvas, 0, 0, outputCanvas.width, outputCanvas.height);
                  
            sendToPeer('colorFrame',outputCanvas.toDataURL("image/jpeg", 0.5));
            //
            var closestBodyIndex = getClosestBodyIndex(frame.body.bodies);
            if(closestBodyIndex !== trackedBodyIndex) {
              if(closestBodyIndex > -1) {
                kinect.trackPixelsForBodyIndices([closestBodyIndex]);
              } else {
                kinect.trackPixelsForBodyIndices(false);
                //clear canvas
                processImageData(emptyPixels.buffer, canvas.width, canvas.height);
              }
            }
            else {
              if(closestBodyIndex > -1) {
                //measure distance from floor
                if(frame.body.floorClipPlane)
                {
                  //get position of left hand
                  var joint = frame.body.bodies[closestBodyIndex].joints[Kinect2.JointType.handLeft];

                  //https://social.msdn.microsoft.com/Forums/en-US/594cf9ed-3fa6-4700-872c-68054cac5bf0/angle-of-kinect-device-and-effect-on-xyz-positional-data?forum=kinectv2sdk
                  var cameraAngleRadians= Math.atan(frame.body.floorClipPlane.z / frame.body.floorClipPlane.y);
                  var cosCameraAngle = Math.cos(cameraAngleRadians);
                  var sinCameraAngle = Math.sin(cameraAngleRadians);
                  var yprime = joint.cameraY * cosCameraAngle + joint.cameraZ * sinCameraAngle;
                  var jointDistanceFromFloor = frame.body.floorClipPlane.w + yprime;

                  //show height in canvas
                  context.beginPath();
                  context.fillStyle = "red";
                  context.arc(joint.colorX * 1920, joint.colorY * 1080, 10, 0, Math.PI * 2, true);
                  context.fill();
                  context.closePath();
                  context.font = "48px sans";
                  context.fillText(jointDistanceFromFloor.toFixed(2) + "m", 20 + joint.colorX * 1920, joint.colorY * 1080);

                  outputContext.beginPath();
                  outputContext.fillStyle = "red";
                  outputContext.arc(joint.colorX * 960, joint.colorY * 540, 10, 0, Math.PI * 2, true);
                  outputContext.fill();
                  outputContext.closePath();
                  outputContext.font = "48px sans";
                  outputContext.fillText(jointDistanceFromFloor.toFixed(2) + "m", 20 + joint.colorX * 960, joint.colorY * 540);

                  var jointDataToSend = { colorX: joint.colorX, colorY: joint.colorY, distance: jointDistanceFromFloor};

                  sendToPeer('floorHeightTracker', jointDataToSend);

                }
              }
            }

            trackedBodyIndex = closestBodyIndex;
          });

          kinect.openMultiSourceReader({
            frameTypes: Kinect2.FrameType.body | Kinect2.FrameType.color
          });
        }


      }

      function stopFHJoint() {
        console.log('stopping FHJoint');
        kinect.closeMultiSourceReader();
      }




      function loadFile(e) {
        //console.log(e);
        window.location.href = e.target.files[0].path;
      }

      function init() {
        document.getElementById('loadfile').addEventListener('change',loadFile);
        canvas = document.getElementById('inputCanvas');
        context = canvas.getContext('2d');
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;

        outputCanvas = document.getElementById('outputCanvas');
        outputContext = outputCanvas.getContext('2d');

        loadFPS();

      }

      window.addEventListener('load',initpeer);
      window.addEventListener('load',init);
</script>

  </head>
  <body style="background-color: white;">
    <h1>Hello Kinect!</h1>

    <br />
    <input type="button" value="Start Skeleton Tracking" onclick="startTracking();">
    <input type="button" value="Stop Skeleton Tracking" onclick="stopTracking();">
    <br />
    <input type="button" value="Start RGB Camera" onclick="startRGB();">
    <input type="button" value="Stop RGB Camera" onclick="stopRGB();">
    <br />
    <input type="button" value="Start Depth Camera" onclick="startDepth();">
    <input type="button" value="Stop Depth Camera" onclick="stopDepth();">
    <br />
    <input type="button" value="Start Key Camera" onclick="startKey();">
    <input type="button" value="Stop Key Camera" onclick="stopKey();">
    <br />
    <input type="button" value="Start WebGL Key Camera" onclick="startGLKey();">
    <input type="button" value="Stop WebGL Key Camera" onclick="stopGLKey();">
    <br />
    <input type="button" value="Start Infrared Camera" onclick="startInfrared();">
    <input type="button" value="Stop Infrared Camera" onclick="stopInfrared();">
    <br />
    <input type="button" value="Start Long Exposure Infrared" onclick="startLEInfrared();">
    <input type="button" value="Stop Long Exposure Infrared" onclick="stopLEInfrared();">
    <br />
    <input type="button" value="Start Floor Height Joint" onclick="startFHJoint();">
    <input type="button" value="Stop Floor Height Joint" onclick="stopFHJoint();">
    <br />
    <p>color canvas</p>
    <canvas id="colorCanvas" width="1920" height="1080"></canvas>
    <p>input canvas</p>
    <canvas id="inputCanvas" width="1920" height="1080"></canvas>
    <p>output canvas</p>
    <canvas id="outputCanvas" width="960" height="540"></canvas>
    <br />
    Load a different page:
    <input type="file" id="loadfile">
  </body>
</html>
