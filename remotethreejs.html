<html>
  <head>

    <script src="peer.min.js"></script>
    <script src="js/image-buffer-renderer-webgl-browser.js"></script>
    <script src="three.js/build/three.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script type="text/javascript">

      var mypeerid = null;
      var peer = null;
      var connection = null;

      var canvas = null;
      var context = null;
      var imageData = null;
      var imageDataSize = null;
      var imageDataArray = null;

      var image = null;

      //needed?
      var animFrame = null;

      var depthColorBuffer;
      var depthBuffer;

      // Three.js variables 
      var depthWidth = 512, depthHeight = 424;
      var renderer, camera, scene, controls;

      var particles = new THREE.Geometry();
      var colors = [];
      var numParticles = depthWidth * depthHeight;

      var busy = false;

      // webGL image buffer variables
      var colorRenderer = null; 
      var webGLCanvas = null;



      

      peer = new Peer({host: 'liveweb.itp.io', port: 9000, path: '/', secure: true})
      
      peer.on('open', function(id) {
        console.log('My peer ID is: ' + id);
        mypeerid = id;
      });

      peer.on('connection', function(conn) {
        connection = conn;
        connection.on('open', function() {
          console.log("connected");
        });
        connection.on('data', function(data) {
          console.log(data);
        });
      });

      function makeConnection() {
        var peerid = document.getElementById('peerid').value;
        connection = peer.connect(peerid); // get a webrtc DataConnection
        connection.on('open', function(data) {
          console.log("Open data connection with server");
        });

        connection.on('data', function(dataReceived) {
          //console.log(dataReceived);
          if (dataReceived.event == 'bodyFrame') {
            console.log("Body Frame:");
            console.log(dataReceived.data);
          } else if (dataReceived.event == "colorFrame") {
            console.log("Color Frame:");
            image.src = dataReceived.data;
          } else if (dataReceived.event == "depthFrame") {
            console.log("Depth Frame:");
            image.src = dataReceived.data;
          // } else if (dataReceived.event == "startPointCloud") {
          //   console.log('startPointCloud');
          } else if (dataReceived.event == "depthColorFrame") {
            depthColorBuffer = drawBuffer(dataReceived.data, image, colorContext);
            pointCloud(depthColorBuffer, depthBuffer);
          } else if (dataReceived.event == "rawDepthFrame") {
            depthBuffer = drawBuffer(dataReceived.data, image2, depthContext);
           //console.log(depthBuffer);

          } else if (dataReceived.event == "depthBuffers") {
              depthColorBuffer = drawBuffer(dataReceived.data.depthColorBuffer, image, colorContext);
              //depthBuffer = drawBuffer(dataReceived.data.depthBuffer, image2, depthContext);

              //console.log(depthBuffer);
              //pointCloud(depthBuffer, depthColorBuffer);

          }
        });
      }

      window.addEventListener('load', function() {
        canvas = document.getElementById('outputCanvas');
        context = canvas.getContext('2d');

        colorCanvas = document.getElementById('colorCanvas');
        colorContext = colorCanvas.getContext('2d');

        depthCanvas = document.getElementById('depthCanvas');
        depthContext = depthCanvas.getContext('2d');

        canvas.style.display = 'none';
        imageData = context.createImageData(canvas.width, canvas.height);
        imageDataSize = imageData.data.length;
        imageDataArray = imageData.data;

        image = document.getElementById('image');
        image2 = document.getElementById('image2');

        webGLCanvas = document.getElementById('webGLCanvas');
        colorRenderer = new ImageBufferRendererWebgl(webGLCanvas);

        initPointCloud();

      });

      function drawBuffer(data, image, context) {
         image.src = data;
         context.drawImage(image, 0, 0);
         var imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
         var dataBuffer = imageData.data;
         console.log('databuffer');
         console.log(dataBuffer);
         var processedDataBuffer = processImageData(imageData.data, webGLCanvas.width, webGLCanvas.height);
         console.log('processed');
         console.log(processedDataBuffer);
         return processedDataBuffer;
      }
      
      function processImageData(imageBuffer, width, height) {

        if (colorRenderer.isProcessing || (width <= 0) || (height <= 0)) {
        // Don't start processing new data when we are in the middle of
        // processing data already.
        // Also, Only do work if image data to process is of the expected size
        return;
      }

        colorRenderer.isProcessing = true;
        colorRenderer.processImageData(imageBuffer, width, height);
        colorRenderer.isProcessing = false;
      }


      function createGrid() {
        // ground box
        var geometry = new THREE.BoxGeometry( 500, 2, 500 );
        material = new THREE.MeshNormalMaterial();
        var mesh = new THREE.Mesh( geometry, material );
        mesh.position.set( 0, -1, 0 );
        scene.add( mesh );
        mesh = new THREE.GridHelper( 250, 10 );
        scene.add( mesh );

        // axes
        var axis = new THREE.AxisHelper( 250 );
        scene.add( axis );
        renderer.render( scene, camera );

        var geometry = new THREE.BoxGeometry( 50, 20, 50 );
        var material = new THREE.MeshNormalMaterial();
        var box = new THREE.Mesh( geometry, material );
        scene.add( box );
      }

      function createParticles() {
        //create particles
        console.log('createparticles');

        for(var i = 0; i < numParticles; i++) {
          var x = i % depthWidth - depthWidth * 0.5;
          var y = depthHeight - Math.floor(i / depthWidth);
          var vertex = new THREE.Vector3(x, y, Math.random());
          particles.vertices.push(vertex);
          colors[i] = new THREE.Color(0xffffff);
        }
        particles.colors = colors;
        var material = new THREE.PointCloudMaterial( { size: 3, vertexColors: THREE.VertexColors, transparent: true } );
        mesh = new THREE.PointCloud(particles, material);
        scene.add(mesh);
      }

      function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function render() {
        renderer.render( scene, camera );
        controls.update();
        animFrame = requestAnimationFrame(render);
      }

      function initPointCloud(){
        console.log('init point cloud');
        // create three.js scene
        renderer = new THREE.WebGLRenderer( {
          canvas: document.getElementById('cloudCanvas'),
          alpha: 1, antialias: true, clearColor: 0xffffff
        } );

        camera = new THREE.PerspectiveCamera( 40, renderer.domElement.width / renderer.domElement.height, 1, 10000 );
        camera.position.set( 0, 300, 3000 );
        controls = new THREE.TrackballControls( camera, renderer.domElement );

        scene = new THREE.Scene();
        createGrid();
        createParticles();

        window.addEventListener( 'resize', onWindowResize, false );

        onWindowResize();   
        render();

        busy = false;
      }

      function pointCloud(depthBuffer, depthColorBuffer) {
          if(busy) {
            return;
          }

          //console.log('particles');

          busy = true;
          var nDepthMinReliableDistance = 500;
          var nDepthMaxDistance = 4500;
          var mapDepthToByte = nDepthMaxDistance / 256;
          var j = 0, k = 0;

          
          for(var i = 0; i < depthBuffer.length; i+=2) {

            var depth = (depthBuffer[i+1] << 8) + depthBuffer[i]; //get uint16 data from buffer
            //console.log(depth);
            if(depth <= nDepthMinReliableDistance || depth >= nDepthMaxDistance) depth = Number.MAX_VALUE; //push them far far away so we don't see them
            //console.log(particles.vertices[j].z);
            //console.log(particles.colors[j]);
            //console.log(nDepthMaxDistance);
            //console.log(depth);
            //console.log(depthColorBuffer[k]);
            //particles.vertices[j].z = (nDepthMaxDistance - depth) - 2000;
            //particles.colors[j].setRGB(depthColorBuffer[k] / 255, depthColorBuffer[k+1] / 255, depthColorBuffer[k+2] / 255);
            j++;
            k+= 4;
          }
          particles.verticesNeedUpdate = true;
          particles.colorsNeedUpdate = true;
          busy = false;
      }
         



    </script>
  </head>
  <body>
    <input type="text" id="peerid" placeholder="Peer Id To Connect To">
    <input type="button" value="Connect" onclick="makeConnection();">
    <canvas id="outputCanvas" width="1920" height="1080"></canvas>
    <canvas id="cloudCanvas" width="1920" height="1080"></canvas>
    <canvas id="colorCanvas" width="512" height="424"></canvas>
    <canvas id="depthCanvas" width="512" height="424"></canvas>
    <canvas id="webGLCanvas" width="512" height="424"></canvas>
    <img id="image" src="" width="512" height="424">
    <img id="image2" src="" width="512" height="424">    
  </body>
</html>
